import{_ as e,c as r,o as t,a}from"./app.d938ae89.js";const l="/FE/framework/3.png",m=JSON.parse('{"title":"vue-router","description":"","frontmatter":{},"headers":[{"level":2,"title":"使用方式","slug":"使用方式","link":"#使用方式","children":[]},{"level":2,"title":"路由类型","slug":"路由类型","link":"#路由类型","children":[]},{"level":2,"title":"底层原理","slug":"底层原理","link":"#底层原理","children":[]}],"relativePath":"framework/vue-router.md","lastUpdated":1670593134000}'),i={name:"framework/vue-router.md"},o=a('<h1 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-hidden="true">#</a></h1><blockquote><p>地址：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/</a></p></blockquote><p>早先我们不用router的时代，我们通常一个url对应一个html文件或者jsp文件之类的，例如：www.xxx.com=&gt;index.html、<a href="http://www.xxx.com/about=" target="_blank" rel="noreferrer">www.xxx.com/about=</a>&gt;about.html，每次切换url都需要我们的页面重新加载，这样很影响我们的用户体验。</p><p>后来出现了SPA(单页面)开发模式，所有的url对应同一个html文件，切换url不需要页面重新加载，即可执行相对应的逻辑，数据也从接口的形式获取。那么Vue Router就是解决这样的问题：</p><ul><li>监听URL的变化，并在变化前后执行相应的逻辑</li><li>不同的URL对应不同的组件</li><li>提供多种方式改变URL的API(URL的改变不能导致浏览器的刷新)</li></ul><h2 id="使用方式" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式" aria-hidden="true">#</a></h2><ul><li>提供一个路由配置表，不同的URL对应不同组件的配置</li><li>初始化路由实例new VueRouter()</li><li>挂载到Vue实例上</li><li>提供一个路由占位，用来挂载URL匹配到的组件</li></ul><h2 id="路由类型" tabindex="-1">路由类型 <a class="header-anchor" href="#路由类型" aria-hidden="true">#</a></h2><ul><li>Hash模式：丑，无法使用锚点定位</li><li>History模式：需要后端配合，IE9不兼容(可使用强制刷新处理)</li></ul><h2 id="底层原理" tabindex="-1">底层原理 <a class="header-anchor" href="#底层原理" aria-hidden="true">#</a></h2><p>通过使用Vue.util.defineReactive将路由信息设置成响应式，然后通过router-link、$router.push、a href、浏览器前进、后退、手动更改URL等会触发Vue Router源码中的updateRoute方法，在updateRoute方法中去更改路由的响应式数据，数据更改后会自动触发router-view的更新，router-view会根据url匹配到渲染组件， <img src="'+l+'" alt=""></p>',11),u=[o];function h(n,s,d,c,_,p){return t(),r("div",null,u)}const v=e(i,[["render",h]]);export{m as __pageData,v as default};
