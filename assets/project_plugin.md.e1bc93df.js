import{_ as l,v as a,b as i,R as e}from"./chunks/framework.a626a558.js";const o="/FE/project/84.png",q=JSON.parse('{"title":"插件化","description":"","frontmatter":{},"headers":[],"relativePath":"project/plugin.md","filePath":"project/plugin.md","lastUpdated":1683265897000}'),t={name:"project/plugin.md"},r=e('<h1 id="插件化" tabindex="-1">插件化 <a class="header-anchor" href="#插件化" aria-label="Permalink to &quot;插件化&quot;">​</a></h1><p>大家在进行前端开发过程中，可能都会养成一个习惯，当我们面对某一个特定问题，需求解决方案的时候，都会在社区中找好用的插件。如果能够找到匹配的插件，原本两天的工作量，可能半个小时就搞定了。</p><p>不管是以前撑起前端大半江山的JQuery，还是现在提升前端开发体验的构建工具例如Webpack，都采用了插件架构。</p><h2 id="插件架构" tabindex="-1">插件架构 <a class="header-anchor" href="#插件架构" aria-label="Permalink to &quot;插件架构&quot;">​</a></h2><p>插件架构宏观上来讲就是一种框架能够在确定的点上执行外部的代码，而不需要提前知道这部分代码的细节。</p><p>它既可以很简单，也可以很复杂。我们可以编写webpack插件，也可以开发vscode的插件，其基本架构是相似的。</p><p>开发插件需要遵循一些约定，就像网络传输需要协议。它们必须能够被主进程以某种方式获取并使用。通常最初的开发者会发布一些接口或开发套件，允许其他的开发者对原系统开发插件，提供新的能力。</p><p>插件架构师开放封闭原则(OCP)的一种开发原则的体现，表明系统对拓展开放，对修改封闭。插件架构解决了不需要修改核心系统代码而可以对系统增加一些额外的功能特性，只需要一些额外的代码。插件可以单独开发，单独测试。</p><h3 id="插件三要素" tabindex="-1">插件三要素 <a class="header-anchor" href="#插件三要素" aria-label="Permalink to &quot;插件三要素&quot;">​</a></h3><ul><li>pluginCore：插件内核，提供插件运行时，管理插件的加载、运行、卸载等生命周期(类比浏览器)</li><li>pluginAPI：插件运行时需要的基础接口(类比浏览器例子，相当于window)</li><li>plugin：一系列特定功能的独立模块(类比浏览器例子，相当于不同的网页)</li></ul><h3 id="插件核心" tabindex="-1">插件核心 <a class="header-anchor" href="#插件核心" aria-label="Permalink to &quot;插件核心&quot;">​</a></h3><p>插件体系主要分为插件管理、插件连接、插件通信。插件管理中核心系统需要知道哪些插件可以用，注册到哪里，注册顺序等。插件连接是插件的实现规范以及与核心系统的连接规范。插件通信是核心系统提供插件的通讯机制。 <img src="'+o+'" alt=""></p><h3 id="插件架构的好处" tabindex="-1">插件架构的好处 <a class="header-anchor" href="#插件架构的好处" aria-label="Permalink to &quot;插件架构的好处&quot;">​</a></h3><p>插件机制可以保证在系统提供的能力范围内参与系统内部定制化的改造，这为第三方开发提供了更便利的条件，而且这种机制的存在可以激发更多的想法，促进整个生态的发展。采用插件机制有开放生态、拓展性强、无入侵定制化、规则指定等好处。</p><h3 id="插件与组件与库的区别" tabindex="-1">插件与组件与库的区别？ <a class="header-anchor" href="#插件与组件与库的区别" aria-label="Permalink to &quot;插件与组件与库的区别？&quot;">​</a></h3><p>组件是调用者只需关注输入和输出，总思想就是分而治之、重复利用、低耦合。组件解决资源整合问题、增强功能促进开发效率，提高可维护性，便于协同开发。</p><p>插件是参与程序内部运行环节的一段或多段代码集合。即plugin遵循一定规范写出来方便程序展示效果，拥有特定功能且方便调用。</p><p>库是为解决某些特定需求的程序功能集合。即library，如JQuery，常用于方便dom操作、解决浏览器兼容等问题。</p><h2 id="微内核架构思想" tabindex="-1">微内核架构思想 <a class="header-anchor" href="#微内核架构思想" aria-label="Permalink to &quot;微内核架构思想&quot;">​</a></h2><p>插件架构也称为微内核架构，部分复杂项目在不使用微内核设计时，功能过于耦合，不利于拓展和维护。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>微内核架构模式，是软件开发领域非常常见的一种架构模式，非常利于构建松耦合，高扩展的系统。</p></div><p>微内核架构模式的核心是调度器，微内核架构本身不会关注实际业务模块，具体业务模块会通过定义注册插件的方式，从而扩展整个程序的能力。</p><p>由此可以看出基于微内核架构模式设计的系统是非常容易扩展的，同时每个插件相互独立，从而使得系统耦合性低，有利于维护。</p><p>如何开发一个插件调度器？</p><ol><li><p>思考调度器的核心功能</p><ul><li>注册插件功能</li><li>执行插件</li><li>维护整个生命周期的执行上下文</li></ul></li><li><p>思考好的插件设计，迎合调度器</p><ul><li>适当抽象</li><li>简洁API设计</li><li>插件本身的性能优化</li></ul></li></ol><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><p>微内核设计广泛应用于以下场景：</p><ol><li>对拓展性要求非常高(例如编辑器，vscode也是非常棒的案例)</li><li>程序本身不关心业务实现(例如前端微服务架构基座实现)</li><li>开放的程序开发维护权限(任何开发者在看完插件文档后都可以为比较轻松为程序增加新功能)</li></ol><h3 id="优劣势" tabindex="-1">优劣势 <a class="header-anchor" href="#优劣势" aria-label="Permalink to &quot;优劣势&quot;">​</a></h3><ol><li><p>优势</p><ul><li>拓展性高</li><li>本身不关心业务实现</li><li>将业务实现权限移交给开发者</li></ul></li><li><p>劣势：前面提到微内核设计的核心是插件调度器，所以调度器的性能决定了基于微内核设计的程序性能，往往会使程序性能低下。</p></li></ol><blockquote><p>性能主要是花费在遍历插件上</p></blockquote><h2 id="插件生命周期及通信管理" tabindex="-1">插件生命周期及通信管理 <a class="header-anchor" href="#插件生命周期及通信管理" aria-label="Permalink to &quot;插件生命周期及通信管理&quot;">​</a></h2><p>插件化系统设计核心在于插件调度器，主要使用设计模式包含：策略模式、职责链模式。</p><p>调度器内核我们称为Kernel，插件记作Plugin</p><p>插件系统设计就是针对Kernel与Plugin的设计</p><p>Kernel需要具备的：</p><ol><li>系统基础配置(例如一些环境变量相关参数等)(isHmr、isProduction...)</li><li>插件池(plugins) Map</li><li>生命周期钩子(hooks) Map</li></ol><h3 id="插件生命周期" tabindex="-1">插件生命周期 <a class="header-anchor" href="#插件生命周期" aria-label="Permalink to &quot;插件生命周期&quot;">​</a></h3><p>生命周期亦称钩子(Hook)，用于在系统陈旭运行阶段触发对应事件调用，以过往React为例，一个组件的生命周期包含：</p><ul><li>onComponentWillMount</li><li>onComponentDidMount</li><li>onComponentDidCatch</li><li>...</li></ul><p>怎样设计生命周期？插件生命周期设计需要遵循以下原则：</p><ul><li>捋清微内核系统运行逻辑</li><li>特殊节点安插检视点(钩子)</li><li>尽可能少且覆盖大部分场景</li></ul><h3 id="插件通信及交互状态管理" tabindex="-1">插件通信及交互状态管理 <a class="header-anchor" href="#插件通信及交互状态管理" aria-label="Permalink to &quot;插件通信及交互状态管理&quot;">​</a></h3><blockquote><p>插件之间通信需要传信人(执行上下文)</p></blockquote><p>插件调度器从创建到销毁总是维护当前执行的程序执行的上下文，该执行上下文通俗来说可以理解为一个参数对象，存储了执行插件沿途所收集的环境变化。</p><p>以Koa框架为例，ctx上始终维护执行过程中所做的请求、响应更改。</p><h2 id="相关文章" tabindex="-1">相关文章 <a class="header-anchor" href="#相关文章" aria-label="Permalink to &quot;相关文章&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6844903864001380366" target="_blank" rel="noreferrer">为你的JavaScript库提供插件能力</a></li><li><a href="https://yeee.wang/posts/cdd2.html" target="_blank" rel="noreferrer">端上的插件设计</a></li><li><a href="https://mp.weixin.qq.com/s/ZYcmMvk8ccYIsNDEkX1W0Q" target="_blank" rel="noreferrer">前端插件机制剖析及业界案例分析</a></li></ul>',48),p=[r];function n(h,s,c,u,d,b){return a(),i("div",null,p)}const k=l(t,[["render",n]]);export{q as __pageData,k as default};
