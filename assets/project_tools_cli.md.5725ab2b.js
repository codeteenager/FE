import{_ as a,o as s,c as e,Q as l}from"./chunks/framework.d64f6e3c.js";const b=JSON.parse('{"title":"脚手架","description":"","frontmatter":{},"headers":[],"relativePath":"project/tools/cli.md","filePath":"project/tools/cli.md","lastUpdated":1698593248000}'),n={name:"project/tools/cli.md"},r=l(`<h1 id="脚手架" tabindex="-1">脚手架 <a class="header-anchor" href="#脚手架" aria-label="Permalink to &quot;脚手架&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>脚手架是一种用在建筑领域的辅助工具，或者说是为了保证各施工过程顺利进行而搭设的工作平台。</p><p>对应到软件工程领域，脚手架可以解释为帮助开发人员在开发过程中使用的开发工具、开发框架，使用脚手架你无须从头开始搭建或者编写底层软件。</p></div><p>脚手架它的本质作用就是帮助开发者创建项目基础结构、提供项目规范和约定，使开发者可以方便地将注意力集中到业务开发本身。当我们开发相同类型项目时都会有一些相同的约定，包括：</p><ul><li>相同的文件组织结构</li><li>相同的开发范式</li><li>相同的模块依赖</li><li>相同的工具配置</li><li>相同的基础代码</li></ul><p>那么这样就会导致我们在搭建新项目时有大量的重复性工作要去做，脚手架工具就是为了解决这样问题的。我们可以通过脚手架工具去搭建特定项目类型的骨架，然后基于骨架去完成后续的开发工作，例如IDE(Android Studio)创建项目的过程就是一个脚手架的工作流程。</p><p>由于前端技术选型多样，没有统一的标准，所以它的脚手架一般不会放在IDE中，都是以独立的工具存在，而且相对复杂一些。</p><h2 id="脚手架的价值" tabindex="-1">脚手架的价值 <a class="header-anchor" href="#脚手架的价值" aria-label="Permalink to &quot;脚手架的价值&quot;">​</a></h2><ul><li><p>复用原则（Reuse Principle）：现在我们推崇的是极致化的编程体验，缩短的开发时间、大量的开发任务、支持需求的变更、高频率的应用服务交付。这些都给软件开发人员带来了前所未有的压力。其中，软件复用技术被公认为解决这些问题的行之有效的方法。从计算机软件编程的发展历史来看，从面向过程的编程语言到面向对象的高级编程语言的广泛使用，是软件复用技术进步的体现。从对象的复用到更大的组件复用，再到如今的框架的复用、服务的复用，都是在利用他人的优秀成果来放大你的工作价值。当一个新手使用脚手架时，对于一个具体问题，可以套用县城的解决方案加以扩展。使用脚手架的应用，仅需通过简单的朱姐和配置就可以具备健康状态检查、生产环境就绪、可观测等基本服务能力。对于一个业务逻辑问题，可以复用已有的逻辑，一步步迭代，敏捷开发。</p></li><li><p>DRY原则（Dont&#39;t Repeat Yourself）：DRY原则直译过来就是不要重复你自己，这一原则和复用原则类似，强调尽量在项目中减少重复的代码行、重复的方法、重复的模块。其实，软件设计原则和模式最本质的思想都是消除重复。</p></li></ul><p>我们经常提到的重用性和可维护性其实是基于减少重复这一简单而重要的思想的。DRY原则意味着系统内的每一个部件都应该是唯一的，并且是具有明确含义的（不模糊的）。我们可以通过应用职责单一、接口隔离等原则尽量拆分系统、模块、类和方法，使每一个部件都是职责明确且可重复使用的。</p><ul><li>开闭原则（Open Close Principle）：开闭原则中的开就是指对功能的扩展是开放的，闭是指对于原有代码的修改是封闭的。通俗一点讲，软件系统通常是由各种模块组成的，软甲你系统在增加一项新的功能时，应该在不修改现有代码的基础上操作。实现开闭原则的关键就是抽象，从微观的角度讲，开闭原则适用于一个业务模型的类的设计，把系统内的所有可能行为抽象为一个抽象底层，在这个抽象底层中规定需要提供的方法接口，具体实现类通过集成、代理、委托的方式，扩展实现新的行为或者新的功能。从宏观的角度讲，我们说开闭原则就是将公共模块、开发约定、最佳技术实践经过共享、提炼沉淀到封闭的底层技术基座。而将变化频繁的业务模块、独特的功能逻辑通过集成、组合和集成的方式实现对扩展的开放。</li></ul><h2 id="脚手架需求评审" tabindex="-1">脚手架需求评审 <a class="header-anchor" href="#脚手架需求评审" aria-label="Permalink to &quot;脚手架需求评审&quot;">​</a></h2><p>脚手架为了更便于支持开发， 提供了一些实用命令，诸如创建项目、创建模块、测试、打包、发布，初次之外，可以根据自己的的项目需要继续拓展脚手架功能。</p><h3 id="创建项目" tabindex="-1">创建项目 <a class="header-anchor" href="#创建项目" aria-label="Permalink to &quot;创建项目&quot;">​</a></h3><p>创建项目主要流程包含：</p><ul><li>初始化创建环境</li><li>项目配置引导</li><li>获取项目模板</li><li>安装项目依赖</li><li>完成项目创建</li></ul><p>初始化创建环境用于对一些创建相关依赖的检测，比如：Node版本。</p><p>项目配置引导包含开发者输入项目相关信息，包含：项目名称、项目描述、项目所需模板选择等</p><p>通过前面配置，决策出拉取什么项目模板，并拉取</p><p>通过前面配置，决策出拉取什么项目模板，并拉取</p><p>拉取完模板后，执行依赖安装</p><p>项目创建完成，进程结束</p><h3 id="打包项目" tabindex="-1">打包项目 <a class="header-anchor" href="#打包项目" aria-label="Permalink to &quot;打包项目&quot;">​</a></h3><p>打包项目主要流程包含：</p><ul><li>检测打包环境（版本等信息）</li><li>配置打包环境，例如使用rollup等库</li><li>打包</li><li>打包完成</li></ul><h3 id="监听模式启动项目" tabindex="-1">监听模式启动项目 <a class="header-anchor" href="#监听模式启动项目" aria-label="Permalink to &quot;监听模式启动项目&quot;">​</a></h3><p>监听模式启动项目可以实现热更新，实时代码lint等功能，原理类似于webpack热更新</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">&#39;--entry, -i &#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;Entry module&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;watch --entry src/foo.tsx&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;--target&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;Specify your target environment&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;browser&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;watch --target node&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;--name&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;Specify name exposed in UMD builds&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;watch --name foo&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;--format&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;Specify module format(s)&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;cjs,esm&#39;</span></span>
<span class="line"><span style="color:#9ECBFF;">&#39;watch --format cjs,esm&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">&#39;--entry, -i &#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;Entry module&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;watch --entry src/foo.tsx&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;--target&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;Specify your target environment&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;browser&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;watch --target node&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;--name&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;Specify name exposed in UMD builds&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;watch --name foo&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;--format&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;Specify module format(s)&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;cjs,esm&#39;</span></span>
<span class="line"><span style="color:#032F62;">&#39;watch --format cjs,esm&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="项目代码检测" tabindex="-1">项目代码检测 <a class="header-anchor" href="#项目代码检测" aria-label="Permalink to &quot;项目代码检测&quot;">​</a></h3><p>借助eslint可实现项目代码检测，我们通常需要再项目打包构建时，一并执行代码的检测和格式化以及代码压缩</p><p>关于eslint及使用，详见<a href="https://eslint.org/docs/developer-guide/nodejs-api" target="_blank" rel="noreferrer">https://eslint.org/docs/developer-guide/nodejs-api</a></p><h3 id="创建模块" tabindex="-1">创建模块 <a class="header-anchor" href="#创建模块" aria-label="Permalink to &quot;创建模块&quot;">​</a></h3><p>从模板中获取模块模板，并替换模块中的占位数据，根据键入的配置信息生成新模块，流程如下：</p><ul><li>拉取模块</li><li>替换模块占位信息</li><li>生成新模块</li></ul><h3 id="检测当前项目信息" tabindex="-1">检测当前项目信息 <a class="header-anchor" href="#检测当前项目信息" aria-label="Permalink to &quot;检测当前项目信息&quot;">​</a></h3><p>该命令可实现对项目的环境检测，例如当前项目版本、依赖版本及其他相关信息</p><h2 id="常用的脚手架工具" tabindex="-1">常用的脚手架工具 <a class="header-anchor" href="#常用的脚手架工具" aria-label="Permalink to &quot;常用的脚手架工具&quot;">​</a></h2><p>市面上有很多的脚手架工具，但是大都是为了特定项目类型服务的。例如：</p><ul><li>React项目使用create-react-app</li><li>Vue项目使用vue-cli</li><li>Angular项目使用angular-cli</li></ul><p>这些工具都大同小异，根据开发者提供的信息自动的生成项目的特定文件、相关的配置等项目基础结构。</p><p>还有一类像Yeoman为代码的通用型脚手架工具，它可以根据一套模板生成对应的项目结构，这种类型的脚手架工具很灵活也很容易去扩展。</p><p>还有一类脚手架工具Plop，它们在项目开发的过程中创建特定类型的文件，例如创建一个组件或模块所需要的文件，这类模块一般是由特定的文件组成的，而且都有基本的代码结构，相比手动创建，脚手架有更为便捷的创建方式。</p><h2 id="yeoman" tabindex="-1">Yeoman <a class="header-anchor" href="#yeoman" aria-label="Permalink to &quot;Yeoman&quot;">​</a></h2><p>Yeoman的slogan是“THE WEB&#39;S SCAFFOLDING TOOL FOR MODERN WEBAPPS”——面向webapp的脚手架工具。Yeoman不能直接创建项目文件，它提供了一套完整的脚手架开发者API，使用这些API可以定制符合自己业务需求的任意脚手架方案。换句话说，Yeoman不封装任何方案，它是完全开放、高度可扩展的。</p><h2 id="脚手架的工作原理" tabindex="-1">脚手架的工作原理 <a class="header-anchor" href="#脚手架的工作原理" aria-label="Permalink to &quot;脚手架的工作原理&quot;">​</a></h2><p>大部分脚手架工具都很简单，在启动脚手架之后，会自动询问一些预设的问题，然后根据开发者回答的结果结合模板文件生成项目的结构。脚手架工具就是一个Node cli应用，那我们可以创建一个cli应用。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">mkdir</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">test-cli</span><span style="color:#E1E4E8;"> &amp;&amp; </span><span style="color:#79B8FF;">cd</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">test-cli</span></span>
<span class="line"><span style="color:#B392F0;">npm</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">init</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">mkdir</span><span style="color:#24292E;"> </span><span style="color:#032F62;">test-cli</span><span style="color:#24292E;"> &amp;&amp; </span><span style="color:#005CC5;">cd</span><span style="color:#24292E;"> </span><span style="color:#032F62;">test-cli</span></span>
<span class="line"><span style="color:#6F42C1;">npm</span><span style="color:#24292E;"> </span><span style="color:#032F62;">init</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>创建完项目后可以新建一个cli.js，在文件中先声明一个文件头。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//cli.js</span></span>
<span class="line"><span style="color:#E1E4E8;">#</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">usr</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">bin</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">env node</span></span>
<span class="line"><span style="color:#6A737D;">//Node cli应用入口必须要有这样的文件头</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//cli.js</span></span>
<span class="line"><span style="color:#24292E;">#</span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">usr</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">bin</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">env node</span></span>
<span class="line"><span style="color:#6A737D;">//Node cli应用入口必须要有这样的文件头</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>脚手架的工作过程分为两点：1. 通过命令行交互询问用户问题，2. 根据用户回答的结果生成文件</p><p>命令行交互询问使用<a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noreferrer">inquirer</a>库来实现。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">npm</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">install</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">inquirer</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--save</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">npm</span><span style="color:#24292E;"> </span><span style="color:#032F62;">install</span><span style="color:#24292E;"> </span><span style="color:#032F62;">inquirer</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--save</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>生成文件可以使用<a href="https://github.com/mde/ejs" target="_blank" rel="noreferrer">ejs</a>模板引擎来实现</p><h2 id="命令行工具原理和实现" tabindex="-1">命令行工具原理和实现 <a class="header-anchor" href="#命令行工具原理和实现" aria-label="Permalink to &quot;命令行工具原理和实现&quot;">​</a></h2><p>现代脚手架离不开命令行工具，命令行工具即 Command-line interfaces（CLIs） ，是编程领域的重要概念，也是我们开发中经常接触到的工具之一。</p><p>比如 Webpack、Babel、npm、Yarn 等都是典型的命令行。此外，流畅的命令行能够迅速启动一个脚手架，实现自动化和智能化流程。这一部分，我们就使用 Node.js 来开发一个命令行。</p><p>我们先来看几个开发命令行工具的关键依赖。</p><ul><li><a href="http://npm.im/inquirer" target="_blank" rel="noreferrer">inquirer</a>、<a href="http://npm.im/enquirer" target="_blank" rel="noreferrer">enquirer</a>、<a href="https://npm.im/prompts" target="_blank" rel="noreferrer">prompts</a>：可以处理复杂的用户输入，完成命令行输入交互。</li><li><a href="http://npm.im/chalk" target="_blank" rel="noreferrer">chalk</a>、<a href="https://npm.im/kleur" target="_blank" rel="noreferrer">kleur</a>：使终端可以输出彩色信息文案。</li><li><a href="http://npm.im/ora" target="_blank" rel="noreferrer">ora</a>：可以让命令行出现好看的 Spinners。</li><li><a href="http://npm.im/boxen" target="_blank" rel="noreferrer">boxen</a>：可以在命令行中画出 Boxes 区块。</li><li><a href="http://npm.im/listr" target="_blank" rel="noreferrer">listr</a>：可以在命令行中画出进度列表。</li><li><a href="http://npm.im/meow" target="_blank" rel="noreferrer">meow</a>、<a href="http://npm.im/arg" target="_blank" rel="noreferrer">arg</a>：可以进行基础的命令行参数解析。</li><li><a href="http://npm.im/commander" target="_blank" rel="noreferrer">commander</a>、<a href="https://www.npmjs.com/package/yargs" target="_blank" rel="noreferrer">yargs</a>：可以进行更加复杂的命令行参数解析。</li></ul><h2 id="脚手架方案设计" tabindex="-1">脚手架方案设计 <a class="header-anchor" href="#脚手架方案设计" aria-label="Permalink to &quot;脚手架方案设计&quot;">​</a></h2><h3 id="技术选型" tabindex="-1">技术选型 <a class="header-anchor" href="#技术选型" aria-label="Permalink to &quot;技术选型&quot;">​</a></h3><ul><li>commander处理命令</li><li>enquirer命令行交互</li><li>chalk为命令上色</li><li>semver环境检测，依赖约束</li><li>fs-extra文件操作</li></ul><h3 id="初始化脚手架项目" tabindex="-1">初始化脚手架项目 <a class="header-anchor" href="#初始化脚手架项目" aria-label="Permalink to &quot;初始化脚手架项目&quot;">​</a></h3><ol><li>创建node项目</li><li>安装commander，编写一个hello命令，实现控制台输出&quot;你好&quot;</li><li>发布到本地包</li><li>使用这个脚手架</li></ol><h3 id="定义一个项目模版" tabindex="-1">定义一个项目模版 <a class="header-anchor" href="#定义一个项目模版" aria-label="Permalink to &quot;定义一个项目模版&quot;">​</a></h3><h4 id="准备模板" tabindex="-1">准备模板 <a class="header-anchor" href="#准备模板" aria-label="Permalink to &quot;准备模板&quot;">​</a></h4><p>通常，模板的获取有两个途径：</p><ol><li>本地定义，更方便，但是更新相对比较麻烦</li><li>单独托管到github，创建时拉取，方便更新和维护，但是因为受网络影响，可能会影响用户使用体验</li></ol><h4 id="选择模板" tabindex="-1">选择模板 <a class="header-anchor" href="#选择模板" aria-label="Permalink to &quot;选择模板&quot;">​</a></h4><p>如果我们项目需要配置很多模板，则可以定义多模板，然后根据项目模板选择，拷贝指定模板生成新项目</p><h4 id="打包与检测" tabindex="-1">打包与检测 <a class="header-anchor" href="#打包与检测" aria-label="Permalink to &quot;打包与检测&quot;">​</a></h4><p>打包我们可以选择rollup提供的node api进行，代码检测可以使用eslint提供的node api进行。</p><h2 id="相关文章" tabindex="-1">相关文章 <a class="header-anchor" href="#相关文章" aria-label="Permalink to &quot;相关文章&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6844903839246581773" target="_blank" rel="noreferrer">打造灵活可扩展的前端工程化框架</a></li><li><a href="https://juejin.cn/post/7049576737490862093" target="_blank" rel="noreferrer">leo：从工程化角度出发的前端脚手架</a></li><li><a href="https://zhuanlan.zhihu.com/p/311818609" target="_blank" rel="noreferrer">58金融前端脚手架的设计与实现</a></li><li><a href="https://mp.weixin.qq.com/s/de7_BN4jQkeTyOk0bhDrTQ" target="_blank" rel="noreferrer">前端工程化-VSCode插件集成脚手架和组件库</a></li></ul>`,72),p=[r];function o(t,i,c,h,d,u){return s(),e("div",null,p)}const y=a(n,[["render",o]]);export{b as __pageData,y as default};
