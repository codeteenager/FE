import{_ as s,c as a,o as l,V as e}from"./chunks/framework.fc39353b.js";const n="/FE/project/48.png",o="/FE/project/49.png",m=JSON.parse('{"title":"无包构建(No-Bundle/Unbundle)","description":"","frontmatter":{},"headers":[],"relativePath":"project/build/nobundle.md","lastUpdated":1670850418000}'),p={name:"project/build/nobundle.md"},t=e(`<h1 id="无包构建-no-bundle-unbundle" tabindex="-1">无包构建(No-Bundle/Unbundle) <a class="header-anchor" href="#无包构建-no-bundle-unbundle" aria-label="Permalink to &quot;无包构建(No-Bundle/Unbundle)&quot;">​</a></h1><p>无包构建是指在构建时只需处理模块的编译而无须打包，把模块间的依赖关系完全交给浏览器来处理。浏览器会加载入口模块，分析依赖后，再通过网络请求加载被依赖的模块。通过这样的方式简化构建时的处理过程，提升构建效率。</p><p>这种通过浏览器原生的模块进行解析的方式又称为 Native-ESM(Native ES Module)，例如：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//./src/index.html</span></span>
<span class="line"><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./modules/foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//.src/modules/foo.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./bar.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">appendHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./common.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">https://cdn.jsdelivr.net/npm/lodash-es@4.17.15/slice.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">module</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{...}</span><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在没有任何构建工具处理的情况下，在页面中引入带有 type=&quot;module&quot; 属性的 script，浏览器就会在加载入口模块时依次加载了所有被依赖的模块。</p><h2 id="基于浏览器的-js-模块加载功能" tabindex="-1">基于浏览器的 JS 模块加载功能 <a class="header-anchor" href="#基于浏览器的-js-模块加载功能" aria-label="Permalink to &quot;基于浏览器的 JS 模块加载功能&quot;">​</a></h2><p>从 <a href="https://caniuse.com/es6-module" target="_blank" rel="noreferrer">caniuse</a> 网站中可以看到，目前大部分主流的浏览器都已支持 JavaScript modules 这一特性，如下图所示： <img src="`+n+`" alt=""></p><p>这种加载方式有以下特点：</p><ol><li><p>HTML 中的 Script 引用：</p><ul><li>入口模块文件在页面中引用时需要带上**type=&quot;module&quot;**属性。对应的，存在 type=&quot;nomodule&quot;，即支持 ES Module 的现代浏览器，它会忽略 type=&quot;nomodule&quot; 属性的 script，因此可以用作旧浏览器中的降级方案。</li><li>带有 type=&quot;module&quot; 属性的 script在浏览器中通过 defer 的方式异步执行（异步下载，不阻塞 HTML，顺次执行），即使是行内的 script 代码也遵循这一原则（而普通的行内 script 代码则忽略 defer 属性）。</li><li>带有 type=&quot;module&quot; 属性且带有async属性的 script，在浏览器中通过 async 的方式异步执行（异步下载，不阻塞 HTML，按该模块和所依赖的模块下载完成的先后顺序执行，无视 DOM 中的加载顺序），即使是行内的 script 代码，也遵循这一原则（而普通的行内 script 代码则忽略 async 属性）。</li><li>即使多次加载相同模块，也只会执行一次。</li></ul></li><li><p>模块内依赖的引用</p><ul><li>只能使用 import ... from &#39;...&#39; 的 ES6 风格的模块导入方式，或者使用 import(...).then(...) 的 ES6 动态导入方式，不支持其他模块化规范的引用方式（例如 require、define 等）。</li><li>导入的模块只支持使用相对路径（&#39;/xxx&#39;, &#39;./xxx&#39;, &#39;../xxx&#39;）和 URL 方式（<code>https://xxx</code>, <code>http://xxx</code>）进行引用，不支持直接使用包名开头的方式（&#39;xxxx&#39;, &#39;xxx/xxx&#39;）。</li><li>只支持引用MIME Type为 text/javascript 方式的模块，不支持其他类型文件的加载（例如 CSS 等）。</li></ul></li></ol><p>从上面的技术细节中我们会发现，对于一个普通的项目而言，要使用这种加载方案仍然有几个主要问题：</p><ol><li>许多其他类型的文件需要编译处理为 ES6 模块才能被浏览器正常加载（JSX、Vue、TS、CSS、Image 等）。</li><li>许多第三方依赖包在通过第三方 URL 引用时，不仅过程烦琐，而且往往难以进行灵活的版本控制与更新，因此需要合适的方式来解决引用路径的问题。</li><li>对于现实中的项目开发而言，一些便利的辅助开发技术，例如热更新等还是需要由构建工具来提供。</li></ol><p>针对以上问题可以使用<a href="http://www.vitejs.net/" target="_blank" rel="noreferrer">Vite</a>或<a href="https://www.snowpack.dev/" target="_blank" rel="noreferrer">Snowpack</a>构建工具来解决。</p><h2 id="无包构建的优点" tabindex="-1">无包构建的优点 <a class="header-anchor" href="#无包构建的优点" aria-label="Permalink to &quot;无包构建的优点&quot;">​</a></h2><p>无包构建的最大优势在于构建速度快，尤其是启动服务的初次构建速度要比目前主流的打包构建工具要快很多，原因如下：</p><ul><li>初次构建启动快：打包构建流程在初次启动时需要进行一系列的模块依赖分析与编译，而在无包构建流程中，这些工作都是在浏览器渲染页面时异步处理的，启动服务时只需要做少量的优化处理即可（例如缓存项目依赖的 Bare Modules），所以启动非常快。</li><li>按需编译：在打包构建流程中，启动服务时即需要完整编译打包所有模块，而无包构建流程是在浏览器渲染时，根据入口模块分析加载所需模块，编译过程按需处理，因此相比之下处理内容更少，速度也会更快</li><li>增量构建速度快：在修改代码后的 rebuild 过程中，主流的打包构建中仍然包含编译被修改的模块和打包产物这两个主要流程，因此相比之下，只需处理编译单个模块的无包构建在速度上也会更胜一筹（尽管在打包构建工具中，也可以通过分包等方式尽可能地减少两者的差距）。</li></ul><h2 id="无包构建的缺点" tabindex="-1">无包构建的缺点 <a class="header-anchor" href="#无包构建的缺点" aria-label="Permalink to &quot;无包构建的缺点&quot;">​</a></h2><ul><li>浏览器网络请求数量剧增：无包构建最主要面对的问题是，它的运行模式决定了在一般项目里，渲染页面所需发起的请求数远比打包构建要多得多，使得打开页面会产生瀑布式的大量网络请求，将对页面的渲染造成延迟。这对于服务稳定性和访问性能要求更高的生产环境而言，通常是不太能接受的，尤其对不支持 HTTP/2 的服务器而言，这种处理更是灾难性的。因此，一般是在开发环境下才使用无包构建，在生产环境下则仍旧使用打包构建。</li><li>浏览器的兼容性：无包构建要求浏览器支持 JavaScript module 特性，尽管目前的主流浏览器已大多支持，但是对于需要兼容旧浏览器的项目而言，仍然不可能在生产环境下使用。而在开发环境下则通常没有这种顾虑。</li></ul><h2 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;vite&quot;">​</a></h2><p><a href="https://github.com/vitejs/vite" target="_blank" rel="noreferrer">Vite</a> 是 Vue 框架的作者尤雨溪最新推出的基于 Native-ESM 的 Web 构建工具。它在开发环境下基于 Native-ESM 处理构建过程，只编译不打包，在生产环境下则基于 Rollup 打包。例如：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">init</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">vite-app</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example-vite</span></span>
<span class="line"><span style="color:#82AAFF;">cd</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example-vite</span></span>
<span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span></span>
<span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">dev</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="`+o+`" alt=""> 可以看到，运行示例代码后，在浏览器中只引入了 src/main.js 这一个入口模块，但是在网络面板中却依次加载了若干依赖模块，包括外部模块 vue 和 css。</p><h3 id="对-html-文件的预处理" tabindex="-1">对 HTML 文件的预处理 <a class="header-anchor" href="#对-html-文件的预处理" aria-label="Permalink to &quot;对 HTML 文件的预处理&quot;">​</a></h3><p>当启动 Vite 时，会通过 serverPluginHtml.ts 注入 /vite/client 运行时的依赖模块，该模块用于处理热更新，以及提供更新 CSS 的方法 updateStyle。</p><h3 id="对外部依赖包的解析" tabindex="-1">对外部依赖包的解析 <a class="header-anchor" href="#对外部依赖包的解析" aria-label="Permalink to &quot;对外部依赖包的解析&quot;">​</a></h3><p>首先是对不带路径前缀的外部依赖包（也称为Bare Modules）的解析，例如上图中在示例源代码中导入了 &#39;vue&#39; 模块，但是在浏览器的网络请求中变为了请求 /@module/vue。这个解析过程在 Vite 中主要通过三个文件来处理：</p><ul><li>resolver.ts 负责找到对应在 node_modules 中的真实依赖包代码（Vite 会在启动服务时对项目 package.json 中的 dependencies 做预处理读取并存入缓存目录 node_modules/.vite_opt_cache 中）。</li><li>serverPluginModuleRewrite.ts 负责把源码中的 bare modules 加上 /@module/ 前缀。</li><li>serverPluginModuleResolve.ts 负责解析加上前缀后的模块。</li></ul><h3 id="对-vue-文件的解析" tabindex="-1">对 Vue 文件的解析 <a class="header-anchor" href="#对-vue-文件的解析" aria-label="Permalink to &quot;对 Vue 文件的解析&quot;">​</a></h3><p>是对 Vue文件的解析通过 serverPluginVue.ts 处理的，分离出 Vue 代码中的 script/template/style 代码片段，并分别转换为 JS 模块，然后将 template/style 模块的 import写到script 模块代码的头部。因此在浏览器访问时，一个 Vue 源代码文件会分裂为 2~3 的关联请求(例如上面的 <code>/src/App.vue</code> 和 <code>/src/App.vue?type=template</code>，如果 App.vue 中包含 <code>&lt;style</code>&gt; 则会产生第 3 个请求 <code>/src/App.vue?type=style</code>)。 对Vue的解析。</p><h3 id="对-css-文件的解析" tabindex="-1">对 CSS 文件的解析 <a class="header-anchor" href="#对-css-文件的解析" aria-label="Permalink to &quot;对 CSS 文件的解析&quot;">​</a></h3><p>对 CSS 文件的解析是通过 serverPluginCSS.ts 处理的，解析过程主要是将 CSS 文件的内容转换为下面的 JS 代码模块，其中的 updateStyle 由注入 HTML 中的 /vite/client 模块提供，如下所示：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">updateStyle</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/vite/client</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> css </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">...</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#82AAFF;">updateStyle</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#C3E88D;">...</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> css) </span><span style="color:#676E95;font-style:italic;">// id, cssContent</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> css</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以上就是示例代码中主要文件类型的基本解析逻辑，可以看到，Vite 正是通过这些解析器来解决不同类型文件以 JS 模块的方式在浏览器中加载的问题。在 Vite 源码中还包含了其他更多文件类型的解析器，例如 JSON、TS、SASS 等。</p><h3 id="vite其他功能" tabindex="-1">Vite其他功能 <a class="header-anchor" href="#vite其他功能" aria-label="Permalink to &quot;Vite其他功能&quot;">​</a></h3><ul><li>多框架：除了在默认的 Vue 中使用外，还支持在 React 和 Preact 项目中使用。工具默认提供了 Vue、React 和 Preact 对应的脚手架模板。</li><li>热更新（HMR）：默认提供的 3 种框架的脚手架模板中都内置了 HMR 功能，同时也提供了 HMR 的 API 供第三方插件或项目代码使用。</li><li>自定义配置文件：支持使用自定义配置文件来细化构建配置，配置项功能参考 config.ts。</li><li>HTTPS 与 HTTP/2：支持使用 --https 启动参数来开启使用 HTTPS 和 HTTP/2 协议的开发服务器。</li><li>服务代理：在自定义配置中支持配置代理，将部分请求代理到第三方服务。</li><li>模式与环境变量：支持通过 mode 来指定构建模式为 development 或 production。相应模式下自动读取 dotenv 类型的环境变量配置文件（例如 .env.production.local）。</li><li>生产环境打包：生产环境使用 Rollup 进行打包，支持传入自定义配置，配置项功能参考 build/index.ts。</li></ul><h3 id="vite使用限制" tabindex="-1">Vite使用限制 <a class="header-anchor" href="#vite使用限制" aria-label="Permalink to &quot;Vite使用限制&quot;">​</a></h3><ul><li>面向支持 ES6 的现代浏览器，在生产环境下，编译目标参数 esBuildTarget 的默认值为 es2019，最低支持版本为 es2015（因为内部会使用 esbuild 处理编译压缩，用来获得最快的构建速度）。</li><li>对 Vue 框架的支持目前仅限于最新的 Vue 3 版本，不兼容更低版本。</li></ul><h2 id="snowpack" tabindex="-1">Snowpack <a class="header-anchor" href="#snowpack" aria-label="Permalink to &quot;Snowpack&quot;">​</a></h2><p>Snowpack 是另一个比较知名的无包构建工具，从整体功能来说和上述 Vite工具提供的功能大致相同，主要差异点在 Snowpack 在生产环境下默认使用无包构建而非打包模式（可以通过引入打包插件例如 @snowpack/plugin-webpack 来实现打包模式），而 Vite 仅在开发模式下使用。</p>`,38),r=[t];function c(i,u,d,y,D,F){return l(),a("div",null,r)}const h=s(p,[["render",c]]);export{m as __pageData,h as default};
