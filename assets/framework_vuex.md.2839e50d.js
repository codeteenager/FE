import{_ as s,c as a,o as n,a as e}from"./app.64fc31e5.js";const l="/FE/framework/1.png",t="/FE/framework/2.png",m=JSON.parse('{"title":"Vuex","description":"","frontmatter":{},"headers":[{"level":2,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[]},{"level":2,"title":"底层原理","slug":"底层原理","link":"#底层原理","children":[]},{"level":2,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[]}],"relativePath":"framework/vuex.md","lastUpdated":1670593134000}'),p={name:"framework/vuex.md"},o=e('<h1 id="vuex" tabindex="-1">Vuex <a class="header-anchor" href="#vuex" aria-hidden="true">#</a></h1><blockquote><p>Vuex官网地址：<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noreferrer">https://vuex.vuejs.org/zh/</a></p></blockquote><p>在官网上对Vuex有一个说明，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。</p><p>这个状态管理主要包含以下三个部分：</p><ul><li>状态，驱动应用的数据源；</li><li>视图，以声明方式将状态映射到视图；</li><li>操作，响应在视图上的用户输入导致的状态变化。</li></ul><p><img src="'+l+'" alt=""></p><p>从图中可以看到整个系统的运行是一个单向的，我们的数据驱动视图的更新，用户在视图上进行一些操作，然后触发action，通过action的方式去更改state，而不是视图直接更改state，</p><p>然后看一下Vuex的运行机制，它不和组件进行强关联，可以独立的提供响应式数据。在图中可以看到Vuex提供的state数据驱动Vue Components视图，视图通过Dispatch派发action，我们在action中可以进行一些异步的操作，比如通过ajax请求接口获取后端数据，然后通过commit方式提交到Mutation，然后由mutation最终更改state。那么为什么要经过一层mutation呢？主要是为了在Devtools中记录数据的变化，这样我们可以通过插件来调试。所以说mutation是一个纯同步的操作，如果你有异步的操作需要在action中处理。如果没有异步的操作，可以从组件直接commit到mutation的。</p><p><img src="'+t+`" alt=""></p><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-hidden="true">#</a></h2><p>核心概念共分为以下五个部分：</p><ul><li>State：<a href="http://this.$store.state.xxx" target="_blank" rel="noreferrer">this.$store.state.xxx</a> 取值</li><li>Getter：<a href="http://this.$store.getters.xxx" target="_blank" rel="noreferrer">this.$store.getters.xxx</a> 取值，有一个缓存的效果</li><li>Mutation：this.$store.commit(&quot;xxx&quot;) 赋值</li><li>Action：this.$store.dispatch(&quot;xxx&quot;) 赋值，经过commit</li><li>Module</li></ul><h2 id="底层原理" tabindex="-1">底层原理 <a class="header-anchor" href="#底层原理" aria-hidden="true">#</a></h2><ul><li>State：最核心的提供了一个响应式数据</li><li>Getter：借助Vue的计算属性computed来实现缓存</li><li>Mutation：更改state方法</li><li>Action：触发mutation方法</li><li>Module：Vue.set动态添加state到响应式数据中</li></ul><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-hidden="true">#</a></h2><h4 id="使用常量替代mutation事件类型" tabindex="-1">使用常量替代Mutation事件类型 <a class="header-anchor" href="#使用常量替代mutation事件类型" aria-hidden="true">#</a></h4><p>通过使用常量来替代Mutation事件类型，这样可以把事件类型单独放在一个文件中，使用起来很方便，有助于团队协作。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">//mutation-types.js</span></span>
<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> SOME_MUTATION </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">SOME_MUTATION</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">//store.js</span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> Vuex </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vuex</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">SOME_MUTATION</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./mutation-types</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> store </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> Vuex</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Store</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">state</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{...},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">mutations</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;">//计算属性命名功能：使用一个常量作为函数名</span></span>
<span class="line"><span style="color:#A6ACCD;">        [SOME_MUTATION]</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;">//mutate state</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="开启命名空间" tabindex="-1">开启命名空间 <a class="header-anchor" href="#开启命名空间" aria-hidden="true">#</a></h4><p>随着项目的扩大，我们有很多的状态需要管理，这里建议对所有的模块开始命名空间namespaced:true，嵌套模块不要太深，尽量扁平化，灵活应用createNamespacedHelpers。</p>`,21),r=[o];function c(i,u,D,d,y,F){return n(),a("div",null,r)}const A=s(p,[["render",c]]);export{m as __pageData,A as default};
