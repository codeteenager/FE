import{_ as o,o as n,c as s,C as e,a as t}from"./chunks/framework.980dd5bd.js";const x=JSON.parse('{"title":"Web Components","description":"","frontmatter":{},"headers":[],"relativePath":"web/foundation/web-components.md","filePath":"web/foundation/web-components.md","lastUpdated":1687107606000}'),a={name:"web/foundation/web-components.md"},c=e("h1",{id:"web-components",tabindex:"-1"},[t("Web Components "),e("a",{class:"header-anchor",href:"#web-components","aria-label":'Permalink to "Web Components"'},"​")],-1),l=e("p",null,"如果问你开发项目的时候，为什么不手写原生JS，而是用现如今非常流行的前端框架呢？原因肯定非常多，比如良好的生态、数据驱动视图、模块化、组件化等等，Web Components就是为了解决组件化这个问题而诞生的，它是浏览器原生支持的组件化，不依赖于任何库或框架以及各种编辑打包工具，便可以在浏览器中运行。组件化的好处相必不便多说，大家都用过vue、react这类知名框架，懂得都懂。但是这类框架的组件化不是真正的组件化，虽然写代码时写得是组件化的代码，但是编译过后就不再是组件化了。",-1),d=e("p",null,[t("比如我们用Vue + Element UI开发了一套后台管理系统，Element UI提供的组件都是以el开头的，像"),e("code",null,"<el-button>"),t("，但是编译过后显示在页面上就不是el-button标签了，这有点类似于CSS预处理器，那些像Saas、Less在开发阶段定义的变量其实并不是真正的变量，而是伪变量，在编译过后就没有变量这个概念了，所以很难跟JS进行通信。同理，框架的组件化也都不是真正的组件化，各家都是各家的组件化标准，这就导致了生态的分裂。而且框架的组件化都是要靠编译才能实现的。并且非常依赖于这个框架，是一种共生的关系。就像我们写xxx.vue是vue的组件，它没办法在浏览器中运行。")],-1),p=e("p",null,"通常来说浏览器厂商会吸收一些流行的前端框架的可取之处，然后推动其成为标准，并在浏览器中原生实现其功能。Web Components与现在非常流行的mvvm框架是一种可以共存的关系，而不是一种互斥的关系。像saas变量和css变量，两者可以完美的互补。",-1),r=[c,l,d,p];function m(i,_,b,u,h,f){return n(),s("div",null,r)}const C=o(a,[["render",m]]);export{x as __pageData,C as default};
